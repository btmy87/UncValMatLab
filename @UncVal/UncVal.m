classdef UncVal < matlab.mixin.indexing.RedefinesParen
    %UNCVAL Calculations with uncertainty
    %   Perform standard matlab calculations with uncertainty
    %   Propagates uncertainty with derivatives using an autodiff like
    %   method
    

    properties (SetAccess=private)
        val double % value
        id string % string id
        uncType string % uncertainty type
    end
    properties (SetAccess=private, Dependent)
        std_unc % standard uncertainty
        var_srcs % table with sources of variance
    end
    properties (SetAccess=private, Hidden)
        srcs % dictionary of sources of variance and sensitivity factors
    end
    properties (Constant, Hidden)
        calcId = "calc" % ID used for results of calculations
        calcType = "1-sigma" % Uncertainty type to be assigned on calcs.
        constId = "const" % ID used for constants
    end
    
    methods
        function obj = UncVal(val, unc, id, opts)
            %UncVal construct an uncertain value
            %   UncVal(val, unc, id) returns an UncVal object with the given
            %   value, uncertainty, and id
            % 
            % INPUTS:
            %  - val: nominal value, default = []
            %  - unc: uncertainty input, default zero
            %         input 1-sigma, 2-sigma, or uniform depending on 
            %         opts.uncType
            %  - id:  globally unique string for tracking sensitivity
            %         id will be generated by default, but should use a
            %         meaningful name.  Items with separate id's must be
            %         statistically independent.  Values that are
            %         identically the same must have the same id.  No
            %         support for user defined values that are partially
            %         correlated.  Try to create independent values and
            %         run calculations to capture partial correlation.
            %  - opts.uncType: One of "1-sigma", "2-sigma", or uniform
            %                  For 1-sigma, set `unc` equal to 1-sigma
            %                  level.  For 2-sigma, set `unc` equal to
            %                  2-sigma level.  For "uniform", set `unc`
            %                  equal to the +/- uniform uncertainty.

            arguments
                val double = []
                unc double {mustBeNonnegative} = 0.0
                id (1, 1) string = ""
                opts.uncType (1, 1) string {mustBeMember(opts.uncType, ...
                    ["1-sigma", "2-sigma", "uniform"])} = "1-sigma";
            end


            assert(id~=UncVal.calcId, ...
                "UncVal:InvalidId", ...
                "UncVal id '%s' cannot be used. This is reserved for internal use.", ...
                UncVal.calcId);
            assert(~(id==UncVal.constId && unc > 0.0), ...
                "UncVal:InvalidId", ...
                "UncVal id '%s' cannot be used. This is reserved for internal use.", ...
                UncVal.constId);

            %calculate standard uncertainty from input
            if opts.uncType == "2-sigma"
                unc = unc./2;
            elseif opts.uncType == "uniform"
                unc = unc./sqrt(3);
            end
            obj.uncType = opts.uncType;


            % make an id if the user didn't supply one
            if id == ""
                id = UncVal.makeId();
            end

            % expand the uncertainty to match the size of val in case
            % the user gives a scalar unc and an array val
            obj.val = val;
            obj.id = id;

            % create dictionary to track srcs of variance.  Expand out
            % everything to the size of val. 
            % obj.srcs = configureDictionary("string", "struct"); % >=2023b
            obj.srcs = dictionary();
            obj.srcs(id) = struct("xvar", unc.^2 + zeros(size(val)), ...
                                  "sens", ones(size(val)));
        end

        function out = get.var_srcs(obj)
            % var_srcs returns table with names and sources of variance for object
            names = obj.srcs.keys;
            
            sens = [obj.srcs.values.sens]';
            xvars = [obj.srcs.values.xvar]';
            vars = sens.^2.*xvars;
            
            out = table();
            out.name = names;
            out.var = vars;
            out.var_frac = out.var./sum(out.var);
            out.src_var = xvars;
            out.src_unc = sqrt(xvars);
            out.sens = sens;
            out = sortrows(out, "var", "descend");
        end

        function out = get.std_unc(obj)
            % returns the standard uncertainty, really only a separate
            % property to make a more useful display
            out = obj.unc();
        end

        varargout = size(obj,varargin);
        C = cat(dim,varargin);

    end
    methods (Static=true)
        obj = UncValInt(val, xvar, srcs); % internal use constructor
        obj = makeUncVal(val);
        str = makeId();
        obj = empty(varargin);
        srcs = propagate(xSrcs, ySrcs, Cx, Cy);
        % h = errorbar(varargin);
    end
    methods (Access=protected)
        varargout = parenReference(obj, indexOp);
        n = parenListLength(obj,indexOp,indexContext);
        updatedObj = parenDelete(obj,indexOp);
        updatedObj = parenAssign(obj,indexOp,varargin);% not implemented
    end
end

